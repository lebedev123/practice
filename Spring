






Существует такое понятие как Inversion of Control, по-русски – Инверсия управления, сокращенно – IoC. IoC — один из принципов, приближающий наш код к слабосвязанности. IoC — это делегирование части наших обязанностей внешнему компоненту.


Существуют разные реализации IoC подхода, нас интересует одна из них — Dependency Injection, внедрение зависимостей. Чт
Бин — создаваемый Spring-ом объект класса, который можно внедрить в качестве значения поля в другой объект.
Инверсия управления - это принцип разработки программного обеспечения, согласно которому управление объектами или частями программы передается контейнеру или фреймворку. Чаще всего используется в контексте объектно-ориентированного программирования.

IOC 
В отличие от традиционного программирования, в котором наш пользовательский код выполняет вызовы библиотеки, IoC позволяет фреймворку управлять выполнением программы и выполнять вызовы нашего пользовательского кода. Для этого фреймворки используют абстракции со встроенным дополнительным поведением. 
Преимущества этой архитектуры:

отделение выполнения задачи от ее реализации
упрощая переключение между различными реализациями
большая модульность программы
большая легкость тестирования программы за счет изоляции компонента или имитации его зависимостей и разрешения компонентам обмениваться данными через контракты


DI
Внедрение зависимостей - это шаблон для реализации IoC, где инвертируемый элемент управления - это установка зависимостей объекта.

Акт соединения объектов с другими объектами или «инъекции» объектов в другие объекты выполняется фраемворком, а не самими объектами.
Контейнер IoC - это общая характеристика фреймворков, реализующих IoC.

В среде Spring контейнер IoC представлен интерфейсом ApplicationContext. Контейнер Spring отвечает за создание экземпляров, настройку и сборку объектов, известных как beans, а также за управление их жизненным циклом.

Платформа Spring предоставляет несколько реализаций интерфейса ApplicationContext - ClassPathXmlApplicationContext и FileSystemXmlApplicationContext для автономных приложений и WebApplicationContext для веб-приложений.

Для сборки bean-компонентов контейнер использует метаданные конфигурации, которые могут быть в форме XML-конфигурации или аннотаций.

Короче говоря, IoC - это гораздо более широкий термин, который включает, но не ограничивается, DI

Термин «инверсия управления» (IoC) изначально означал любой стиль программирования, в котором общая структура или среда выполнения управляли ходом программы.

До того, как у DI появилось имя, люди начали называть фреймворки, управляющие зависимостями, инверсией управляющих контейнеров, и вскоре значение IoC постепенно сместилось к этому конкретному значению: инверсия управления зависимостями.

Инверсия управления (IoC) означает, что объекты не создают других объектов, на которых они полагаются для выполнения своей работы. Вместо этого они получают необходимые объекты из внешнего источника (например, из файла конфигурации xml).

Внедрение зависимостей (DI) означает, что это выполняется без вмешательства объекта, обычно с помощью компонента инфраструктуры, который передает параметры конструктора и устанавливает свойства.



Тот, кто контролирует все ваши классы и может управлять ими соответствующим образом (читай: создайте их с необходимыми зависимостями), называется ApplicationContext во вселенной Spring.

Scope("singleton") → Ваш бин будет синглтоном, т.е. будет только один экземпляр.
Scope("prototype") → Каждый раз, когда кому-то нужна ссылка на ваш компонент, Spring создает новый. (Здесь есть несколько предостережений, например, внедрения прототипов в синглтоны).
Scope("session") → Для каждого сеанса HTTP пользователя будет создан один компонент.

То, что делает эта аннотация @ComponentScan, это сказать Spring: Посмотрите на все классы Java в том же пакете, что и конфигурация контекста, если они выглядят как Spring Bean!

@Transactional для этого метода сигнализирует Spring, что для работы этого метода необходимо открытое соединение с базой данных / транзакция и что указанная транзакция также должна быть зафиксирована в конце. И Spring должна сделать это.
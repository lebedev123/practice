
https://github.com/enhorse/java-interview
																							Java

	Java SE																							
Внутренние и локальные классы
Вложенные классы находятся внутри других классов.
Объекты внутреннего класса могут быть созданы только при наличии обхекта внешнего класса. Он имеет доступ ко всем полням внешнего класса.
Статические вложенные классы можно создать  без наличия объекта внешн класса, не имеет доступа к НЕ статическим полям внешн класса.
Локальный класс объявляется в методе и блоке и может создавать только в рамках этого блока.
Аннонимный класс создается без имени , создание его экземпляра происходит одновременно с объявлением . Может быть создан как реализация интерфейса (new Comparable(){...}) или как наследник определенного класса (наслденик класса Foo - Foo foo = new Foo(){...}).


hotspot vm

String intern
Позволяет аллоцировать объект в пуле строк

All object methods
equals()
getClass
hashcode
notify
notifyAll
toString
wait
clone - см ниже
finalize

Ковариантность и инвариантность
Ковариантность сохранение порядка наследования для производных типов ( List<? extends Number> a = new ArrayList<Integer>();)
Инвариантность - отсутсвие свойств ковариантности (так делать нельзя List<Number> a = new ArrayList<Integer>();)

clone protected - потому что у каждого объекта должна быть дефолтная имплементация (у базовых типов уже есть super.clone()), а засунуть можно только в Object

equals and hashcode 
Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают true, тогда и x.equals(z) вернёт true;
Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y),постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при условии, что никакая информация, используемая при сравнении объектов, не поменялась.
Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false

Типы ссылок (https://habr.com/ru/post/169883/)
Strong References - любая переменная ссылочного типа. Очистится сборщиком мусора не раньше, чем станет неиспользуемой (перестанет быть доступной из GC roots).
SoftReference — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти. (позволяет получить стронг ссылку через метод get если объект еще не удален) 
WeakReference — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.
PhantomReference — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.


Иерархия коллекций
Enumeration
Iterator & ListIterator
Сколько весит ссылка в жава и сам объект
Double & Long
Hashmap && null
EnumSet
Java 8 date /Calendar, map/flatmap
default methods in inteface
Области Heap'a


Работа GC
Сборщик мусора (Garbage Collector) должен делать всего две вещи:
 	Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из
сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
	Освобождать память от мусора.
Существует два подхода к обнаружению мусора:
 - Reference counting;
 - Tracing
Reference counting (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет
счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка
уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать
мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика.
Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают
друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.
Главная идея подхода Tracing (трассировка) состоит в утверждении, что живыми могут считаться
только те объекты, до которых мы можем добраться из корневых точек (GC Root) и те объекты,
которые доступны с живого объекта. Всё остальное - мусор.
Существует 4 типа корневых точки:
 - Локальные переменные и параметры методов;
 - Потоки;
 - Статические переменные;
 - Ссылки из JNI.
Самое простое java приложение будет иметь корневые точки:
 - Локальные переменные внутри main() метода и параметры main() метода;
 - Поток который выполняет main();
 - Статические переменные класса, внутри которого находится main() метод.
Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем
добраться - не мусор, все остальные - мусор. При таком подходе циклические зависимости легко
выявляются. HotSpot VM использует именно такой подход.
Для очистки памяти от мусора существуют два основных метода:
 - Copying collectors
 - Mark-and-sweep
При copying collectors подходе память делится на две части «from-space» и «to-space», при этом сам
принцип работы такой:
 Объекты создаются в «from-space»;
 Когда «from-space» заполняется, приложение приостанавливается;
 Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «tospace»;
 Когда все объекты скопированы «from-space» полностью очищается;
 «to-space» и «from-space» меняются местами.
Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:
 Приложение должно быть остановлено на время, необходимое для полного прохождения цикла
сборки мусора;
 В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.
Алгоритм работы mark-and-sweep можно описать так:
 - Объекты создаются в памяти;
 - В момент, когда нужно запустить сборщик мусора приложение приостанавливается;
 - Сборщик проходится по дереву объектов, помечая живые объекты;
 - Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в
«free list»;
 - Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».
Минусы этого способа:
 - Приложение не работает пока происходит сборка мусора;
 - Время остановки напрямую зависит от размеров памяти и количества объектов;
 - Если не использовать «compacting» память будет использоваться не эффективно.
Сборщики мусора HotSpot VM используют комбинированный подход Generational Garbage
Collection, который позволяет использовать разные алгоритмы для разных этапов сборки мусора.
Этот подход опирается на том, что:
 - большинство создаваемых объектов быстро становятся мусором;
 - существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.
Как работает сборщик мусора?
Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления
новых объектов.
Объекты создаются посредством оператора new, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив
переменной ссылку на другой объект или значение null; прекратить выполнение метода, чтобы его
локальные переменные завершили свое существование естественным образом. Объекты, ссылки на
которые отсутствуют, принято называть мусором (garbage), который будет удален.
Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект,
обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого
кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти.
Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим
посредством цепочки ссылок, начиная с корневой (GC Root) ссылки, т.е. ссылки, непосредственно
существующей в выполняемом коде.
Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может
успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к
этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.
Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но
это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления
большого количества объектов существенным образом сказывается на производительности приложений и если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора,
подлежащего утилизации.

	Java io/nio


	Многопоточность
Состояния потока
Concurrent
wait/notify
CountDownLatch/CyclicBarrier
race condition
ReentrantLock & ReadWriteLock
double checked locking Singleton
синхронизаторы

	Сборка
War,jar,ear
Maven/Gradle

	Паттерны


	Тестирование
JUNIT/Mockito

	Spring
Boot
JPA
Integration
MVC
Security


	Other
Java EE
CGI
JTA





																							DB
Нормализация БД

Типы индексов
По воздействию на источник данных
 - кластерный индекс - при определении в наборе данных физическое расположение данных перестраивается в соответствии со структурой индекса. Логическая структура набора данных в этом
случае представляет собой скорее словарь, чем индекс. Данные в словаре физически упорядочены,
например по алфавиту. Кластерные индексы могут дать существенное увеличение производительности поиска данных даже по сравнению с обычными индексами. Увеличение производительности
особенно заметно при работе с последовательными данными.
 - некластерный индекс — наиболее типичные представители семейства индексов. В отличие от
кластерных, они не перестраивают физическую структуру набора данных, а лишь организуют ссылки на соответствующие записи. Для идентификации нужной записи в наборе данных некластерный
индекс организует специальные указатели, включающие в себя: информацию об идентификационном номере файла, в котором хранится запись; идентификационный номер страницы соответствующих данных; номер искомой записи на соответствующей странице; содержимое столбца.
Некластерные индексы - данные физически расположены в произвольном порядке, но логически
упорядочены согласно индексу. Такой тип индексов подходит для часто изменяемого набора данных.
При кластерном индексировании данные физически упорядочены, что серьезно повышает скорость
выборок данных (но только в случае последовательного доступа к данным). Для одного набора данных может быть создан только один кластерный индекс.
По структуре
 B*-деревья;
 B+-деревья;
 B-деревья;
 Хэши.

NoSQL



Транзакция
Транзакция - это воздействие на базу данных, переводящее её из одного целостного состояния в
другое и выражаемое в изменении данных, хранящихся в базе данных.
Атомарность (atomicity) гарантирует, что никакая транзакция не будет зафиксирована в системе
частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.
Согласованность (consistency). Транзакция, достигающая своего нормального завершения и, тем
самым, фиксирующая свои результаты, сохраняет согласованность базы данных.
Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
Долговечность (durability). Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией,
должны остаться сохранёнными после возвращения системы в работу

Уровни изолированности транзакций
В порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными:
 - Чтение неподтверждённых данных (грязное чтение) (read uncommitted, dirty read) — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии,
что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате
их отката, поэтому такое чтение является потенциальным источником ошибок. Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы.
 - Чтение подтверждённых данных (read committed) — чтение всех изменений своей транзакции и
зафиксированных изменений параллельных транзакций. Потерянные изменения и грязное чтение
не допускается, возможны неповторяемое чтение и фантомы.
 - Повторяемость чтения (repeatable read, snapshot) — чтение всех изменений своей транзакции,
любые изменения, внесённые параллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы.
 - Упорядочиваемость (serializable) — результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо
последовательного выполнения. Проблемы синхронизации не возникают.

Репликация и шардирование



																						SQL

DML (Data Manipulation lang) - Create, Alter, Drop
DDL (Data Definition lang) - Select, Insert, Update, Delete
DCL (Data control lang) - Grand , Revoke, Deny
TCL (Transaction Control Lang) - Commit, Rollback
PL/psql
Blob?


																						Linux
Sticky bit/ GUID,










																						Other
TeamCity/Jenkins,Kibana, Consul, Vault
PCI DSS
КриптоПро
SVN/GIT
Loggers
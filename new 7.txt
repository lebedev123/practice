https://github.com/enhorse/java-interview
																							Java

	Java SE																							
Внутренние и локальные классы
Вложенные классы находятся внутри других классов.
Объекты внутреннего класса могут быть созданы только при наличии обхекта внешнего класса. Он имеет доступ ко всем полням внешнего класса.
Статические вложенные классы можно создать  без наличия объекта внешн класса, не имеет доступа к НЕ статическим полям внешн класса.
Локальный класс объявляется в методе и блоке и может создавать только в рамках этого блока.
Аннонимный класс создается без имени , создание его экземпляра происходит одновременно с объявлением . Может быть создан как реализация интерфейса (new Comparable(){...}) или как наследник определенного класса (наслденик класса Foo - Foo foo = new Foo(){...}).


hotspot vm - реализация jvm от oracle

String intern
Позволяет аллоцировать объект в пуле строк

All object methods
equals()
getClass
hashcode
notify
notifyAll
toString
wait
clone - см ниже
finalize

Ковариантность и инвариантность
Ковариантность сохранение порядка наследования для производных типов ( List<? extends Number> a = new ArrayList<Integer>();)
Инвариантность - отсутсвие свойств ковариантности (так делать нельзя List<Number> a = new ArrayList<Integer>();)

clone protected - потому что у каждого объекта должна быть дефолтная имплементация (у базовых типов уже есть super.clone()), а засунуть можно только в Object

equals and hashcode 
Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают true, тогда и x.equals(z) вернёт true;
Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y),постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при условии, что никакая информация, используемая при сравнении объектов, не поменялась.
Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false

Типы ссылок (https://habr.com/ru/post/169883/)
Все типы ссылок (кроме стронг) наследуются от reference , когда GC видит такой объект он помещает ссылку в referencequeue (referenceQueue можно передать в конструктор reference)
Strong References - любая переменная ссылочного типа. Очистится сборщиком мусора не раньше, чем станет неиспользуемой (перестанет быть доступной из GC roots).

SoftReference — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти. (позволяет получить стронг ссылку через метод get если объект еще не удален) 
GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError.
Главная плюшка SoftReference в том что JVM сама следит за тем нужно удалять из памяти объект или нет. И если осталось мало памяти, то объект будет удален. Это именно то, что нам нужно при кэшировании.
SoftReference это механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы. 

WeakReference — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.
Сначала GC очистит weak-ссылку, то есть weakRef.get() – будет возвращать null. Потом weakRef будет добавлен в queue и соответственно queue.poll() вернет ссылку на weakRef.
Используется в WeakHashMap

PhantomReference — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.
Особенностей у этого типа ссылок две. Первая это то, что метод get() всегда возвращает null. Именно из-за этого PhantomReference имеет смысл использовать только вместе с ReferenceQueue. 
В отличие от SoftReference и WeakReference, GC добавит phantom-ссылку в ReferenceQueue послетого как выполниться метод finalize(). Тоесть фактически, в отличии от SoftReference и WeakReference, объект еще есть в памяти.


Иерархия коллекций
List  -ArrayList,LinkedList
Queue - Dequeue(LinkedList),PriorityQueue
Set - TreeSet,HashSet
Map - HashMap,TreeMap	

Сколько весит ссылка в жава и сам объект ,  в 64 битной системе заголовок объекта 16 байт, в 32 - 8 байт .

Double & Long
записи тех же long и double, если они не объявлены как volatile, не обязаны быть атомарными и на многих платформах записываются в две операции: старшие и младшие 32 бита отдельно


EnumSet

Java 8 date /Calendar, 

Stream api


java.time.LocalDate, java.time.LocalTime, java.time.LocalDateTime

Области Heap'a
Eden Space (heap) – в этой области выделятся память под все создаваемые из программы объекты. Большая часть объектов живет недолго (итераторы, временные объекты, используемые внутри методов и т.п.), и удаляются при выполнении сборок мусора это области памяти, не перемещаются в другие области памяти. Когда данная область заполняется (т.е. количество выделенной памяти в этой области превышает некоторый заданный процент), GC выполняет быструю (minor collection) сборку мусора. По сравнению с полной сборкой мусора она занимает мало времени, и затрагивает только эту область памяти — очищает от устаревших объектов Eden Space и перемещает выжившие объекты в следующую область.
• Survivor Space (heap) – сюда перемещаются объекты из предыдущей, после того, как они пережили хотя бы одну сборку мусора. Время от времени долгоживущие объекты из этой области перемещаются в Tenured Space.
• Tenured (Old) Generation (heap) — Здесь скапливаются долгоживущие объекты (крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и проч.). Когда заполняется эта область, выполняется полная сборка мусора (full, major collection), которая обрабатывает все созданные JVM объекты.
• Permanent Generation (non-heap) – Здесь хранится метаинформация, используемая JVM (используемые классы, методы и т.п.). В частноси
• Code Cache (non-heap) — эта область используется JVM, когда включена JIT-компиляция, в ней кешируется скомпилированный платформенно — зависимый код.

WSDL & Soap


Знать базовые представления о структуре памяти JVM и принципах работы сборщиков мусора (Serial GC, Parallel GC, Concurrent Mark Sweep GC, G1 GC). Делал попытки прочитать JLS, встречал термин happens-before. 

Работа GC
Сборщик мусора (Garbage Collector) должен делать всего две вещи:
 	Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из
сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
	Освобождать память от мусора.
Существует два подхода к обнаружению мусора:
 - Reference counting;
 - Tracing
Reference counting (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет
счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка
уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать
мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика.
Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают
друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.
Главная идея подхода Tracing (трассировка) состоит в утверждении, что живыми могут считаться
только те объекты, до которых мы можем добраться из корневых точек (GC Root) и те объекты,
которые доступны с живого объекта. Всё остальное - мусор.
Существует 4 типа корневых точки:
 - Локальные переменные и параметры методов;
 - Потоки;
 - Статические переменные;
 - Ссылки из JNI.
Самое простое java приложение будет иметь корневые точки:
 - Локальные переменные внутри main() метода и параметры main() метода;
 - Поток который выполняет main();
 - Статические переменные класса, внутри которого находится main() метод.
Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем
добраться - не мусор, все остальные - мусор. При таком подходе циклические зависимости легко
выявляются. HotSpot VM использует именно такой подход.
Для очистки памяти от мусора существуют два основных метода:
 - Copying collectors
 - Mark-and-sweep
При copying collectors подходе память делится на две части «from-space» и «to-space», при этом сам
принцип работы такой:
 Объекты создаются в «from-space»;
 Когда «from-space» заполняется, приложение приостанавливается;
 Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «tospace»;
 Когда все объекты скопированы «from-space» полностью очищается;
 «to-space» и «from-space» меняются местами.
Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:
 Приложение должно быть остановлено на время, необходимое для полного прохождения цикла
сборки мусора;
 В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.
Алгоритм работы mark-and-sweep можно описать так:
 - Объекты создаются в памяти;
 - В момент, когда нужно запустить сборщик мусора приложение приостанавливается;
 - Сборщик проходится по дереву объектов, помечая живые объекты;
 - Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в
«free list»;
 - Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».
Минусы этого способа:
 - Приложение не работает пока происходит сборка мусора;
 - Время остановки напрямую зависит от размеров памяти и количества объектов;
 - Если не использовать «compacting» память будет использоваться не эффективно.
Сборщики мусора HotSpot VM используют комбинированный подход Generational Garbage
Collection, который позволяет использовать разные алгоритмы для разных этапов сборки мусора.
Этот подход опирается на том, что:
 - большинство создаваемых объектов быстро становятся мусором;
 - существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.
Как работает сборщик мусора?
Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления
новых объектов.
Объекты создаются посредством оператора new, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив
переменной ссылку на другой объект или значение null; прекратить выполнение метода, чтобы его
локальные переменные завершили свое существование естественным образом. Объекты, ссылки на
которые отсутствуют, принято называть мусором (garbage), который будет удален.
Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект,
обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого
кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти.
Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим
посредством цепочки ссылок, начиная с корневой (GC Root) ссылки, т.е. ссылки, непосредственно
существующей в выполняемом коде.
Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может
успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к
этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.
Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но
это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления
большого количества объектов существенным образом сказывается на производительности приложений и если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора,
подлежащего утилизации.

	Java io/nio
Java io потокоориентированный и блокирующий 
Nio - буфероориентированный и неблокирующий
В java io чтение/запись байт поочередно , информация не кешируется, движение в одну сторону.
В nio данные считываются в буфер , можно двигаться вперед/назад 
You can both read and write to a Channels. Streams are typically one-way (read or write).
Channels can be read and written asynchronously.
Channels always read to, or write from, a Buffer.
Here are the most important Channel implementations in Java NIO:
FileChannel
DatagramChannel
SocketChannel
ServerSocketChannel

	Многопоточность
Состояния потока
NEW (created)
	A thread that has not yet started is in this state.
RUNNABLE (start - либо запущен либо ожидает запуска и выделения ресурсов)
	A thread executing in the Java virtual machine is in this state.
BLOCKED (wait for lock on synchro block or metnhod)
	A thread that is blocked waiting for a monitor lock is in this state.
WAITING (wait,join)
	A thread that is waiting indefinitely for another thread to perform a particular action is in this state.
TIMED_WAITING (wait or join with time)
	A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.
TERMINATED (thread terminated - завершил выполнение успешно или нет)
	A thread that has exited is in this state.

concurrent коллекции

wait/notify

CountDownLatch/CyclicBarrier

Starvation
Помимо блокировок (deadlock и livelock) есть ещё одна проблема при работе с многопоточностью — Starvation, или "голодание". От блокировок это явление отличается тем, что потоки не заблокированы, а им просто не хватает ресурсов на всех. Поэтому пока одни потоки на себя берут всё время выполнения, другие не могут выполниться:

race condition
При работе с многопоточностью есть такое понятие, как "состояние гонки". Это явление заключается в том, что потоки делят между собой некоторый ресурс и код написан таким образом, что не предусматривает корректную работу в таком случае. 

Lock-и ReadWriteLock, ReentrantLock, ключевое слово volatile

double checked locking Singleton

синхронизаторы

atomic объекты

happens before
Пусть есть поток X и поток Y (не обязательно отличающийся от потока X). И пусть есть операции A (выполняющаяся в потоке X) и B (выполняющаяся в потоке Y).

В таком случае, A happens-before B означает, что все изменения, выполненные потоком X до момента операции A и изменения, которые повлекла эта операция, видны потоку Y в момент выполнения операции B и после выполнения этой операции.
 1)Освобождение (releasing) монитора happens-before заполучение (acquiring) того же самого монитора.
 2) Запись в volatile переменную happens-before чтение из той же самой переменной.
 3) Запись значения в final-поле (и, если это поле — ссылка, то ещё и всех переменных, достижимых из этого поля (dereference-chain)) при конструировании объекта happens-before запись этого объекта в какую-либо переменную, происходящая вне этого конструктора.


	Сборка
War,jar,ear
.jar files: The .jar files contain libraries, resources and accessories files like property files.

.war files: The war file contains the web application that can be deployed on any servlet/jsp container. The .war file contains jsp, html, javascript and other files necessary for the development of web applications.

Maven/Gradle

	Паттерны


	Тестирование
JUNIT/Mockito

	Spring
Boot
JPA
Integration
MVC
Security


	Other
Java EE
CGI
JTA





																							DB
Нормализация БД

Типы индексов
По воздействию на источник данных
 - кластерный индекс - при определении в наборе данных физическое расположение данных перестраивается в соответствии со структурой индекса. Логическая структура набора данных в этом
случае представляет собой скорее словарь, чем индекс. Данные в словаре физически упорядочены,
например по алфавиту. Кластерные индексы могут дать существенное увеличение производительности поиска данных даже по сравнению с обычными индексами. Увеличение производительности
особенно заметно при работе с последовательными данными.
 - некластерный индекс — наиболее типичные представители семейства индексов. В отличие от
кластерных, они не перестраивают физическую структуру набора данных, а лишь организуют ссылки на соответствующие записи. Для идентификации нужной записи в наборе данных некластерный
индекс организует специальные указатели, включающие в себя: информацию об идентификационном номере файла, в котором хранится запись; идентификационный номер страницы соответствующих данных; номер искомой записи на соответствующей странице; содержимое столбца.
Некластерные индексы - данные физически расположены в произвольном порядке, но логически
упорядочены согласно индексу. Такой тип индексов подходит для часто изменяемого набора данных.
При кластерном индексировании данные физически упорядочены, что серьезно повышает скорость
выборок данных (но только в случае последовательного доступа к данным). Для одного набора данных может быть создан только один кластерный индекс.
По структуре
 B*-деревья;
 B+-деревья;
 B-деревья;
 Хэши.

NoSQL



Транзакция
Транзакция - это воздействие на базу данных, переводящее её из одного целостного состояния в
другое и выражаемое в изменении данных, хранящихся в базе данных.
Атомарность (atomicity) гарантирует, что никакая транзакция не будет зафиксирована в системе
частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.
Согласованность (consistency). Транзакция, достигающая своего нормального завершения и, тем
самым, фиксирующая свои результаты, сохраняет согласованность базы данных.
Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
Долговечность (durability). Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией,
должны остаться сохранёнными после возвращения системы в работу

Уровни изолированности транзакций
В порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными:
 - Чтение неподтверждённых данных (грязное чтение) (read uncommitted, dirty read) — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии,
что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате
их отката, поэтому такое чтение является потенциальным источником ошибок. Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы.
 - Чтение подтверждённых данных (read committed) — чтение всех изменений своей транзакции и
зафиксированных изменений параллельных транзакций. Потерянные изменения и грязное чтение
не допускается, возможны неповторяемое чтение и фантомы.
 - Повторяемость чтения (repeatable read, snapshot) — чтение всех изменений своей транзакции,
любые изменения, внесённые параллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы.
 - Упорядочиваемость (serializable) — результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо
последовательного выполнения. Проблемы синхронизации не возникают.

Репликация и шардирование



																						SQL

DML (Data Manipulation lang) - Create, Alter, Drop
DDL (Data Definition lang) - Select, Insert, Update, Delete
DCL (Data control lang) - Grand , Revoke, Deny
TCL (Transaction Control Lang) - Commit, Rollback
PL/psql
Blob?


																						Linux
Sticky bit/ GUID,










																						Other
TeamCity/Jenkins,Kibana, Consul, Vault
PCI DSS
КриптоПро
SVN/GIT
Loggers
Helm